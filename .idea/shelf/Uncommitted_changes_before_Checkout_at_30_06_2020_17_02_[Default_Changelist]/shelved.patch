Index: GC26.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=\"true\" type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" LANGUAGE_LEVEL=\"JDK_1_7\">\r\n    <output url=\"file://$MODULE_DIR$/target/classes\" />\r\n    <output-test url=\"file://$MODULE_DIR$/target/test-classes\" />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src/main\" isTestSource=\"false\" />\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src/test\" isTestSource=\"true\" />\r\n      <excludeFolder url=\"file://$MODULE_DIR$/target\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- GC26.iml	(revision bdaad50d58565cc0aef6a0513a41faba6acc5cae)
+++ GC26.iml	(date 1593529005886)
@@ -4,11 +4,22 @@
     <output url="file://$MODULE_DIR$/target/classes" />
     <output-test url="file://$MODULE_DIR$/target/test-classes" />
     <content url="file://$MODULE_DIR$">
-      <sourceFolder url="file://$MODULE_DIR$/src/main" isTestSource="false" />
-      <sourceFolder url="file://$MODULE_DIR$/src/test" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
       <excludeFolder url="file://$MODULE_DIR$/target" />
     </content>
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" scope="TEST" name="Maven: junit:junit:4.11" level="project" />
+    <orderEntry type="library" scope="TEST" name="Maven: org.hamcrest:hamcrest-core:1.3" level="project" />
+    <orderEntry type="library" scope="TEST" name="Maven: org.junit.jupiter:junit-jupiter:5.4.1" level="project" />
+    <orderEntry type="library" scope="TEST" name="Maven: org.junit.jupiter:junit-jupiter-api:5.4.1" level="project" />
+    <orderEntry type="library" scope="TEST" name="Maven: org.apiguardian:apiguardian-api:1.0.0" level="project" />
+    <orderEntry type="library" scope="TEST" name="Maven: org.opentest4j:opentest4j:1.1.1" level="project" />
+    <orderEntry type="library" scope="TEST" name="Maven: org.junit.platform:junit-platform-commons:1.4.1" level="project" />
+    <orderEntry type="library" scope="TEST" name="Maven: org.junit.jupiter:junit-jupiter-params:5.4.1" level="project" />
+    <orderEntry type="library" scope="TEST" name="Maven: org.junit.jupiter:junit-jupiter-engine:5.4.1" level="project" />
+    <orderEntry type="library" scope="TEST" name="Maven: org.junit.platform:junit-platform-engine:1.4.1" level="project" />
   </component>
 </module>
\ No newline at end of file
Index: src/main/java/it/polimi/ingsw/gameAction/move/MinotaurMoves.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.polimi.ingsw.gameAction.move;\r\n\r\nimport it.polimi.ingsw.model.Battlefield;\r\nimport it.polimi.ingsw.model.Cell;\r\nimport it.polimi.ingsw.model.GodCard;\r\nimport it.polimi.ingsw.model.Token;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n\r\n/**\r\n * MINOTAUR\r\n *\r\n * Your Worker move into an opponent Workerâ€™s space, if their Worker can\r\n * be forced one space straight backwards to an unoccupied space at any level\r\n */\r\npublic class MinotaurMoves implements MoveBehavior{\r\n\r\n\r\n    /**\r\n     * It considers even the cells in which there is on opponent token, but\r\n     * only in the case the cell behind him (in that direction) is unoccupied/not dome\r\n     * @param selectedToken the token a player want to move,\r\n     * @param otherToken the other player token.\r\n     * @param enemyTokens a list of all enemy tokens.\r\n     * @param enemyGodCards a list of all enemy god cards.\r\n     * @param battlefield the model's battlefield.\r\n     * @return a list of cell in which a player can build.\r\n     * */\r\n    @Override\r\n    public List<Cell> computeValidMoves(Token selectedToken, Token otherToken, List<Token> enemyTokens, GodCard myGodCard, List<GodCard> enemyGodCards, Battlefield battlefield, List<Cell> moveToCheck) {\r\n\r\n        List<Cell> allMoves = new ArrayList<>();\r\n        int provX, provY;\r\n\r\n        for (int i=-1; i<2; i++) {\r\n            provX = selectedToken.getTokenPosition().getPosX() + i;\r\n            for (int j = -1; j < 2; j++) {\r\n                provY = selectedToken.getTokenPosition().getPosY() + j;\r\n                if ((provX >= 0 && provX < 5) && (provY >= 0 && provY < 5) &&\r\n                    (battlefield.getCell(provX, provY).getHeight() -\r\n                     selectedToken.getTokenPosition().getHeight() <= 1) &&\r\n                    (!battlefield.getCell(provX, provY).getIsDome())) {\r\n\r\n                    // Compute if i can push a player\r\n                    if(battlefield.getCell(provX,provY).getThereIsPlayer()){\r\n\r\n                        // If the pushed cell is inside the battlefield\r\n                        if (0<=provX+i && provX+i<5 && 0<=provY+j && provY+j<5) {\r\n                            Cell nextOne = battlefield.getCell(provX + i, provY + j);\r\n\r\n                            if(!(nextOne.getThereIsPlayer() || nextOne.getIsDome() || nextOne.getPosX()>4 || nextOne.getPosY()>4 || nextOne.getPosX()<0 || nextOne.getPosY()<0)){\r\n                                allMoves.add(battlefield.getCell(provX, provY));\r\n                            }\r\n                        }\r\n                    }\r\n                    else{\r\n                        allMoves.add(battlefield.getCell(provX, provY));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        List<Cell> allMovesToReturn = new ArrayList<>(allMoves);\r\n\r\n        // Remove both my tokens and not enemy tokens\r\n        try{\r\n            allMovesToReturn.remove(battlefield.getCell(selectedToken.getTokenPosition()));\r\n        } catch (NullPointerException ignore){}\r\n        try{\r\n            allMovesToReturn.remove(battlefield.getCell(otherToken.getTokenPosition()));\r\n        } catch (NullPointerException ignore){}\r\n\r\n        return allMovesToReturn;\r\n    }\r\n\r\n\r\n    /**\r\n     * Here is handled the push.\r\n     * It set the selected token position to the target cell and, only if there is an\r\n     * enemy token on the target cell, using the deltas of this move, it even moves that token\r\n     * to the next position on that direction\r\n     * @param targetCell the cell to be incremented.\r\n     * @param battlefield the model's battlefield.\r\n     *\r\n     */\r\n    @Override\r\n    public void performMove(Token selectedToken, Token otherToken, List<Token> enemyTokens, Cell targetCell, List<GodCard> enemyGodCards, Battlefield battlefield){\r\n\r\n        int deltaX, deltaY;\r\n        Cell copy = selectedToken.getTokenPosition();\r\n        if (targetCell.getThereIsPlayer()) {\r\n\r\n            for(Token t: enemyTokens) {\r\n                if (t.getTokenPosition().getPosX()==targetCell.getPosX() && t.getTokenPosition().getPosY()==targetCell.getPosY() ){\r\n                    deltaX = targetCell.getPosX() - selectedToken.getTokenPosition().getPosX();\r\n                    deltaY = targetCell.getPosY() - selectedToken.getTokenPosition().getPosY();\r\n                    t.setOldHeight(battlefield.getCell(t.getTokenPosition()).getHeight());\r\n                    t.setTokenPosition(battlefield.getCell(targetCell.getPosX()+deltaX,targetCell.getPosY()+deltaY));\r\n                    battlefield.getCell(targetCell.getPosX()+deltaX,targetCell.getPosY()+deltaY).setOccupied();\r\n                    battlefield.getCell(targetCell).setFree();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        selectedToken.setTokenPosition(targetCell);\r\n        battlefield.getCell(targetCell).setOccupied();\r\n        battlefield.getCell(copy.getPosX(),copy.getPosY()).setFree();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/it/polimi/ingsw/gameAction/move/MinotaurMoves.java	(revision bdaad50d58565cc0aef6a0513a41faba6acc5cae)
+++ src/main/java/it/polimi/ingsw/gameAction/move/MinotaurMoves.java	(date 1593529175373)
@@ -103,7 +103,8 @@
                 }
             }
         }
-        selectedToken.setTokenPosition(targetCell);
+        selectedToken.setOldHeight(battlefield.getCell(selectedToken.getTokenPosition()).getHeight());
+        selectedToken.setTokenPosition(battlefield.getCell(targetCell));
         battlefield.getCell(targetCell).setOccupied();
         battlefield.getCell(copy.getPosX(),copy.getPosY()).setFree();
     }
